#!/bin/bash
# https://developer.fnnas.com/docs/core-concepts/framework

LOG_FILE="${TRIM_PKGVAR}/info.log"
PID_FILE="${TRIM_PKGVAR}/app.pid"

DATA_DIR="${TRIM_PKGVAR}/data"
CFG_FILE="${DATA_DIR}/config.json"

# write the command to start your program here 

# ./openlist  server http://0.0.0.0:5233 --data /vol1/@appdata/OpenList/data 
# start 产生 dameon/pid 存储的pid可能不准确
CMD="${TRIM_APPDEST}/bin/openlist server --data ${DATA_DIR} --config ${CFG_FILE}"

log_msg() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> ${LOG_FILE}
}

log_env() {
    log_msg "环境变量列表:"
    # 系统实际前缀是 PKG / RUN / SERVICE 等
    printenv | grep -E '^(openlist_|TRIM_)' | while IFS='=' read -r k v; do
        log_msg "$k=$v"
    done
}

make_sure_exist_cfg_file() {
    if [ ! -f "${CFG_FILE}" ]; then
        bash -c "${TRIM_APPDEST}/bin/openlist start --data ${DATA_DIR} --config ${CFG_FILE}" >> ${LOG_FILE} 2>&1 &
        sleep 1
        bash -c "${TRIM_APPDEST}/bin/openlist stop --data ${DATA_DIR} --config ${CFG_FILE}" >> ${LOG_FILE} 2>&1 &
        sleep 1
        log_msg "配置文件不存在，创建默认配置文件"
    fi
}

# make_sure_init_password() {
#     local flag_file="${TRIM_APPDEST}/.init_pwd"
#     log_msg "检查是否需要初始化 admin 密码: ${openlist_admin_password}"
#     if [ -n "$openlist_admin_password" ] || [ ! -f "${flag_file}" ]; then
#         # 标记文件不存在 或 openlist_admin_password 为空 时进入
#         make_sure_exist_cfg_file
#         log_msg "初始化【admin】账户"
#         local new_password="${openlist_admin_password:-admin}"
#         bash -c "${TRIM_APPDEST}/bin/openlist admin set ${new_password} --data ${DATA_DIR} --config ${CFG_FILE}" >> ${LOG_FILE} 2>&1 &
#         sleep 1
#         log_msg "设置 admin 账户默认密码: ${new_password}"
#         touch "${flag_file}"   # 创建标记文件，防止下次重复执行
#         # 清空变量，防止重复设置密码
#         unset openlist_admin_password
#         log_msg "标记已处理，防止重复设置密码"
#     fi
#     return 0
# }

# 更新或追加 key=value
# 用法: set_kv FILE KEY VALUE
set_kv(){
  local file=$1 key=$2 val=$3
  # 1. 先转义 / 和 &，防止 sed 出错
  val_esc=$(printf '%s\n' "$val" | sed 's/[\/&]/\\&/g')
  # 2. 如果键已存在则替换，否则追加
  if grep -q "^[[:space:]]*${key}[[:space:]]*=" "$file"; then
    sed -i "s|^[[:space:]]*${key}[[:space:]]*=.*|${key}=${val_esc}|" "$file"
    log_msg "更新 ${key}=${val} 到 ${file}"
  else
    echo "${key}=${val}" >> "$file"
    log_msg "追加 ${key}=${val} 到 ${file}"
  fi
}

reset_admin_password() {
    log_msg "检查是否需要重置 admin 密码"
    if [ -n "$openlist_admin_password" ]; then
        make_sure_exist_cfg_file
        log_msg "开始重置 admin 密码"
        local new_password="${openlist_admin_password:-admin}"
        bash -c "${TRIM_APPDEST}/bin/openlist admin set ${new_password} --data ${DATA_DIR} --config ${CFG_FILE}" >> ${LOG_FILE} 2>&1 &
        sleep 1
        log_msg "设置 admin 账户密码: ${new_password}"
    fi
    return 0
}

make_sure_change_port() {
    make_sure_exist_cfg_file

    # --- 调试：先确认文件存在、可读、是合法 JSON ---
    # log_msg "调试: CFG_FILE=$CFG_FILE 是否存在=$(test -f "$CFG_FILE" && echo yes || echo no)"
    # log_msg "调试: 当前用户=$(whoami) 对文件权限=$(stat -c '%a %U:%G' "$CFG_FILE" 2>/dev/null || echo 无法stat)"

    # 1. 读当前端口
    local target_port="${openlist_http_port:-5244}"
    local curr_port=$(jq -r '.scheme.http_port ' "$CFG_FILE" 2>&1 | tee -a ${LOG_FILE})
    log_msg "当前端口=$curr_port, 目标端口=$target_port"

    if [[ "$curr_port" == "$target_port" ]]; then
        log_msg "端口相同，跳过"
        return 0
    fi

    # 2. 生成新文件
    local tmp="/tmp/config.json.$$.tmp"
    log_msg "开始写入临时文件 $tmp"
    if ! bash -c "jq --arg p '$target_port' '.scheme.http_port = (\$p | tonumber)' '$CFG_FILE' > '$tmp'" 2>>${LOG_FILE}; then
        log_msg "jq 失败，退出码=$?"
        return 1
    fi

    # 3. 原子替换
    log_msg "mv $tmp -> $CFG_FILE"
    if ! mv "$tmp" "$CFG_FILE" 2>>${LOG_FILE}; then
        log_msg "mv 失败，退出码=$?"
        return 1
    fi

    rm -f "$tmp"
    log_msg "配置端口:【${target_port}】完成"
}

start_process() {
    if status; then
        return 0
    fi
    
    log_env
    # make_sure_init_password
    reset_admin_password
    make_sure_change_port

    log_msg "Starting process ..."
    # run cmd to start process

    log_msg "CMD = ${CMD}"
    bash -c "${CMD}" >> ${LOG_FILE} 2>&1 &
    
    # write pid to pidfile
    # printf "%s" "$!" > "${PID_FILE}.txt"
    printf "%s\n" $(pgrep -f "${CMD}") > ${PID_FILE}
    sleep 3
    return 0
}

stop_process() {
    log_msg "Stopping process ..."

    if [ -r "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        
        log_msg "pid=${pid}"
        if ! check_process "${pid}"; then
            # process not exist, delete pidfile
            rm -f "${PID_FILE}"
            log_msg "remove pid file 1"
            return
        fi

        log_msg "send TERM signal to PID:${pid}..."
        kill -TERM ${pid} >> ${LOG_FILE} 2>&1

        local count=0
        while check_process "${pid}" && [ $count -lt 10 ]; do
            sleep 1
            count=$((count + 1))
            log_msg "waiting process terminal... (${count}s/10s)"
        done

        if check_process "${pid}"; then
            log_msg "send KILL signal to PID:${pid}..."
            kill -KILL "${pid}"
            sleep 1
            rm -f "${PID_FILE}"
        else
            log_msg "process killed... "
        fi
    fi

    return 0
}

check_process() {
    local pid=$1
    if kill -0 "${pid}" 2>/dev/null; then
        # log_msg "check status: pid=${pid} is running"
        return 0  # process exist
    else
        log_msg "check status: pid=${pid} is not running"
        return 1  # process not exist
    fi
}

status() {
    if [ -f "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        if check_process "${pid}"; then
            return 0
        else
            # Process is not running but pidfile exists - clean it up
            rm -f "${PID_FILE}"
        fi    
    fi

    return 1
}

case $1 in
start)
    # run start command. exit 0 if success, exit 1 if failed
    start_process
    ;;
stop)
    # run stop command. exit 0 if success, exit 1 if failed
    stop_process
    ;;
status)
    # check application status command. exit 0 if running, exit 3 if not running
    if status; then 
        exit 0
    else 
        exit 3
    fi
    ;;
*)
    exit 1
    ;;
esac